# Entities Directory

## Overview
Директория `entities` содержит определения основных бизнес-сущностей приложения. Эти сущности представляют собой ядро доменной модели и содержат как данные, так и бизнес-правила, связанные с этими данными.

## Файлы

### user.go
Определяет сущность пользователя:

**Структура `User`**:
- `ID`: Уникальный идентификатор пользователя
- `Email`: Email пользователя
- `Name`: Имя пользователя
- `Status`: Статус пользователя (активный, неактивный и т.д.)
- `RegistrationDate`: Дата регистрации
- `LastLoginDate`: Дата последнего входа
- `Preferences`: Предпочтения пользователя
- `Metadata`: Дополнительные метаданные

**Методы**:
- `Validate()`: Проверка корректности данных пользователя
- `IsActive()`: Проверка активности пользователя
- `DaysSinceRegistration()`: Расчет количества дней с момента регистрации

### transaction.go
Определяет сущность транзакции:

**Структура `Transaction`**:
- `ID`: Уникальный идентификатор транзакции
- `UserID`: Идентификатор пользователя
- `Amount`: Сумма транзакции
- `Currency`: Валюта
- `Date`: Дата транзакции
- `Type`: Тип транзакции (покупка, возврат и т.д.)
- `Items`: Список товаров в транзакции
- `Status`: Статус транзакции

**Методы**:
- `Validate()`: Проверка корректности данных транзакции
- `IsRefund()`: Проверка, является ли транзакция возвратом
- `GetItemCount()`: Получение количества товаров в транзакции

### user-metrics.go
Определяет метрики поведения пользователя:

**Структура `UserMetrics`**:
- `UserID`: Идентификатор пользователя
- `Recency`: Время с последней покупки (в днях)
- `Frequency`: Частота покупок (количество за период)
- `MonetaryValue`: Средняя сумма покупки
- `TotalSpent`: Общая сумма покупок
- `PurchaseCount`: Количество покупок
- `LastPurchaseDate`: Дата последней покупки
- `FirstPurchaseDate`: Дата первой покупки
- `AverageDaysBetweenPurchases`: Среднее количество дней между покупками
- `ChurnProbability`: Вероятность оттока

**Методы**:
- `CalculateRFM()`: Расчет RFM-показателей
- `UpdateWithTransaction()`: Обновление метрик на основе новой транзакции
- `GetCustomerLifespan()`: Расчет продолжительности жизни клиента

### segment.go
Определяет сегменты пользователей:

**Структура `Segment`**:
- `ID`: Уникальный идентификатор сегмента
- `Name`: Название сегмента
- `Description`: Описание сегмента
- `Type`: Тип сегмента (RFM, поведенческий и т.д.)
- `Criteria`: Критерии для включения в сегмент
- `CreatedAt`: Дата создания
- `UpdatedAt`: Дата обновления

**Структура `UserSegment`**:
- `UserID`: Идентификатор пользователя
- `SegmentID`: Идентификатор сегмента
- `AssignedAt`: Дата назначения
- `Score`: Оценка соответствия пользователя сегменту

**Методы**:
- `MatchesUser(metrics *UserMetrics)`: Проверка соответствия пользователя критериям сегмента
- `GetCriteriaDescription()`: Получение текстового описания критериев сегмента

### clv.go
Определяет структуры для работы с пожизненной ценностью клиента (CLV):

**Структура `CLV`**:
- `UserID`: Идентификатор пользователя
- `Value`: Значение CLV
- `Currency`: Валюта
- `CalculatedAt`: Дата расчета
- `Forecast`: Прогноз на будущее
- `Confidence`: Уровень уверенности в прогнозе
- `Scenario`: Сценарий расчета (базовый, оптимистичный, пессимистичный)

**Структура `CLVDataPoint`**:
- `UserID`: Идентификатор пользователя
- `Value`: Значение CLV
- `Date`: Дата
- `Scenario`: Сценарий расчета

**Методы**:
- `AdjustForInflation(rate float64)`: Корректировка CLV с учетом инфляции
- `CalculateGrowthRate(previous *CLV)`: Расчет темпа роста CLV
- `GetMonthlyAverage()`: Расчет среднемесячного значения CLV

## Взаимосвязи между сущностями
- `User` связан с `UserMetrics` через `UserID`
- `User` связан с `Transaction` через `UserID`
- `User` связан с `Segment` через `UserSegment`
- `User` связан с `CLV` через `UserID`
- `Transaction` влияет на расчет `UserMetrics`
- `UserMetrics` используется для определения `Segment`
- `UserMetrics` и `Transaction` используются для расчета `CLV`

## Принципы проектирования
1. **Инкапсуляция бизнес-правил**: Сущности содержат методы для работы с данными и проверки бизнес-правил
2. **Неизменяемость**: Сущности спроектированы так, чтобы минимизировать изменение их состояния после создания
3. **Богатая доменная модель**: Сущности содержат не только данные, но и поведение
4. **Валидация**: Каждая сущность отвечает за валидацию своих данных